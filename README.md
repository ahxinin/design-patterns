## 设计模式 

### 面向对象
#### 贫血模型
传统对象模型，只拥有属性。代码实现：ddd -> anemic
#### 充血模型
具备顺序及业务逻辑。代码实现：ddd -> congestion
***
### 单例模式
用于表示全局唯一的类。 代码实现：singleton
***
### 工厂模式
封装对象创建过程，动态创建不同类型的对象。
#### 实现1：简单工厂
代码实现：factory -> simplefactory
#### 实现2：抽象工厂
增加一层抽象，适用于创建过程中需要初始化的场景。代码实现：factory -> completefactory
***
### 建造者模式
将参数校验、赋值的过程，封装成内部类或者单独的类。代码实现：builder
***
### 代理模式
在不改变原始类的情况下，通过代理类给原始类增加新的功能。静态代理可以继承原始类，或者实现同一个接口；动态代理则是在运行时动态的替换。代码实现：proxy
***
### 装饰器模式
多个装饰器进行组合，可用于多种业务场景。代码实现：decorator
***
### 模板模式
子类可以复用父类中提供的模板方法代码，同时还可以对扩展点进行定制化实现。代码实现：template
***
### 策略模式
实现相同功能的一组策略，调用方无需感知内部细节。
#### 实现1：简单工厂实现
新增策略需要实现策略接口 Strategy，并在工厂类中初始化时增加新的策略类。
代码实现：strategy -> simple
#### 实现2：spring自动装配注入Map
新增策略需要实现策略接口 ItemQueryService，标注服务名称。
代码实现：strategy -> annotation
#### 实现3：spring织入
新增策略需要实现策略接口 ShopRankHandler
代码实现：strategy -> spring
***
### 责任链模式
每个处理器承担独立职责，可组合使用，形成一条处理链。代码实现：chain
***