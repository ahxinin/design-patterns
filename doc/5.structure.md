# 5.结构型

### 1.代理模式

在不改变原始类的情况下，通过引入代理类来给原始类附加功能。

**静态代理：**

- 让代理类和原始类实现同样的接口；
- 让代理类继承原始类的方法；

**动态代理：**

- 静态代理需要为每一个类创建一个代理类，成本较高，可以通过动态代理来解决；
- 不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类；

应用场景：常用于在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志等等；也可用于RPC、缓存等应用场景。

---

### 2.装饰器模式

装饰器模式主要解决继承关系过于复杂的问题，通过组合来代替继承。它主要的作用是给原始类增加增强功能。

另外，装饰器模式可以对原始类嵌套使用多个装饰器，在设计时，装饰器类需要跟原始类继承相同的类或者接口。

经典案例：Java IO类；

应用场景：商品组合优惠金额计算；

---

### 3.适配器模式

适配器模式是用来做适配，将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式可以看作是一种”补偿模式“，用来补救设计上的缺陷。

经典案例：Java Slf4j日志框架；

实现方式：

- 类适配器：使用继承关系来实现；
- 对象适配器：使用组合关系来实现。

使用场景：

- 封装有缺陷的接口设计；
- 统一多个类的接口设计；
- 替换依赖的外部系统；
- 兼容老版本接口；
- 适配不同格式的数据。

---

### 4.门面模式

针对接口设计的粒度，需要在可复用性和易用性之间进行权衡，尽量保持接口的可复用性，特殊情况下可以通过提供冗余的门面接口，来提供更易用的接口。

门面模式除了解决接口的易用性之外，还可以用来解决性能问题和分布式事务问题（减少为了请求、在同一个事务中完成多个操作）。

---